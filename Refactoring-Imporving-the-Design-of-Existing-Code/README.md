# 重构：改善既有代码的设计 （Refactoring Improving the Design of Existing-Code）
## 第1章 重构，第一个案例
- 重构的第一步：为即将修改的代码建立一组可靠的测试环境。
- 代码分解和重组，删除局部变量，抽取方法，移动方法到使用的数据所属的对象内，修改变量名。
- 使用state模式，运用多态取代条件表达式，修改价格相关的条件逻辑。
## 第2章 重构原则
### 2.1 何为重构
* 名词形式定义：对软件内部结构的一种调整，目的是在**不改变软件可观察行为**的前提下，提高其可理解性，降低其修改成本。
* 动词形式定义：使用一系列重构手法，在**不改变软件可观察行为**的前提下，调整其结构。
### 2.2 为何重构
* 重构改进软件设计。
* 重构使软件更容易理解。
    * 后期更新维护更加容易。
    * 提高理解层次从代码层面到设计层面。
* 重构帮助找到bug。
* 重构提高编程速度。
### 2.3 何时重构
**三次法则**：事不过三，三则重构。
* 添加新功能时重构。
* 修补错误时重构。
* 复审代码时重构。
### 2.4 怎么对经理说
* 不要告诉经理，如果自己认为最快完成的方式就是重构，那么就进行重构。
#### 2.4.1 间接层的价值
* 允许逻辑共享
* 分开解释意图和实现
* 隔离变化
* 封装条件逻辑
### 2.5 重构的难题
#### 2.5.1 数据库
* 问题：应用程序与数据库耦合紧密，数据迁移过程漫长而繁琐。
* 解决方法
    * 非对象数据库：在对象模型和数据库模型中间插入一个分隔层，隔离两个模型各自的变化。
    * 对象数据库：数据未被转移前就先运用访问函数造成“数据已经转移”的假象，一旦确定知道数据应该在何处，就可以一次性迁移过去。
#### 2.5.2 修改已发布的接口
* 同时维护新旧两个接口，直到所有的用户都有时间对这个变化做出反应。让旧接口调用新接口，旧函数调用新函数，不要复制函数实现。
* 除非真的有必要，否则不要发布接口。
#### 2.5.3 难以通过重构手法完成的设计改动
* 选择设计方案时，考虑重构为另一个设计的难度，尽量选择简单易重构的设计。
#### 2.5.4 何时不该重构
* 应该重新编写所有代码时，不应该重构而应该重写。
* 项目接近最后期限时，不应该重构。
### 2.6 重构与设计
* 重构可以带来更简单的设计，同时又不损失灵活性，这也降低了设计过程的难度，减轻了设计压力。
### 2.7 重构与性能
* 编写快速软件：首先写出可调的软件，然后调整它以求获得足够速度。
* 在性能优化阶段（开发后期），找出性能热点的代码，持续关注，反复测试优化。
* 构造良好的程序对性能优化的帮助：
    * 可帮助空出更多时间处理性能问题。
    * 可进行更细粒度的代码分析，帮助调整性能。
* 短期来看，重构使得软件变慢，但它使得优化阶段的性能调整更加容易，最终会得到更好效果。
### 第三章 代码的坏味道
#### 3.1 重复代码（Duplicated Code）
* 特点
    * 同一个类的两个函数具有相同的表达式。
    * 两个互为兄弟的子类内含有相同的表达式。
    * 两个毫不相关的类出现重复代码。
* 方案：提炼重复代码，抽取为通用方法。
#### 3.2 过长函数（Long Method）
* 每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。
#### 3.3 过大的类（Large Class）
* 如果一个类中有太多实例变量，那么可以多次使用Extract Class（提炼类）和Extract Subclass（提炼子类）方法。
#### 3.4 过长参数列（Long Parameter List）
* 太长的参数列难以理解，可以用函数或者对象取代参数传递到函数当中。
#### 3.5 发散式变化（Divergent Change）
* 如果某个类经常应为不同的原因在不同的方向上发生变化，那么就可以分为多个类去处理。
* 针对某一外界变化的所有相应修改，都只应该发生在单一类中，而这个新类内的所有内容都应该反应此变化。
#### 3.6 霰弹式修改（Shotgun Surgery）
* 如果每次变化都需要修改不同类的多处，就可以考虑将需要修改的代码放进同一个类。
#### 3.7 依恋情结（Feature Envy）
* 将总是一起变化的东西放在一块，如果有例外出现，就搬移那些行为，保持变化只在一地发生。
#### 3.8 数据泥团（Data Clumps）
* 可以将两个类中的相同字段、许多函数签名中的相同参数提炼到一个独立对象当中。